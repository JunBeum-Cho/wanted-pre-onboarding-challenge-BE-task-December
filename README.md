## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*
  


## 1-2) 사전 과제

### (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.
동기와 비동기 프로그래밍의 관점은 호출한 대상 A이 호출된 대상 B의 작업의 완료 상태를 확인하는지에 따라 작업 순서를 보장하는가에 있습니다.

동기 처리 방식은 태스크를 순서대로 하나씩 처리하므로 실행 순서가 보장된다는 장점이 있지만, 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹되는 단점이 있습니다.

비동기 처리 방식은 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하므로 블로킹이 발생하지 않는다는 장점이 있지만, 태스크의 실행 순서가 보장되지 않는 단점이 있습니다.


### (2) 블로킹과 논블로킹의 차이점을 설명해주세요.
블로킹과 논블로킹의 관점은 호출된 대상이 제어권을 바로 반환(return)하는지 혹은 가지고 있는지에 있습니다.

블로킹(Bloking)은 A 함수가 B 함수를 호출 할 때, B 함수가 자신의 작업이 종료되기 전까지 A 함수에게 제어권을 돌려주지 않는 것입니다.

논블로킹(Non-Blocking)은 A 함수가 B 함수를 호출 할 때, B 함수가 제어권을 바로 A 함수에게 넘겨주면서, A 함수가 다른 일을 할 수 있도록 하는 것입니다.

### (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.
자바에서는 Thread를 이용해 비동기 코드를 작성할 수 있습니다.

Thread를 사용하지 않는 코드
```java
public class ThreadExample {
    public static void main(String[] args) {
        // 작업 1 - 1.5초 소요
        System.out.println("작업1 시작");
        try {
            Thread.sleep(1500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("작업1 종료");

        // 작업 2 - 0.5초 소요
        System.out.println("작업2 시작");
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("작업2 종료");
    }
}

/*결과
작업1 시작
작업1 종료
작업2 시작
작업2 종료
*/
```
실행 시간이 긴 작업1을 스레드로 변경한 코드
```java
public class ThreadExample {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();

        // 작업1 (스레드)
        executorService.submit(() -> {
            log("작업 1 시작");
            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log("작업 1 종료");
        });

        // 작업2
        log("작업 2 시작");
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log("작업 2 종료");

        executorService.shutdown();
    }

    // 출력을 어떤 스레드에서 하고 있는지 확인
    private static void log(String content) {
        System.out.println(Thread.currentThread().getName() + "> " + content);
    }
}

/*결과
main> 작업 2 시작
pool-1-thread-1> 작업 1 시작
main> 작업 2 종료
pool-1-thread-1> 작업 1 종료
*/

```

코드 출처) https://velog.io/@pllap/Java에서의-비동기-프로그래밍

---
실행 시간이 긴 작업1을 다른 쓰레드에게 맡기고, 메인 스레드는 바로 작업2를 실행하게 됩니다. 실행 결과를 보면, main과 oool-1-thread-1의 두 쓰레드가 서로 다른 작업을 동시에 진행하는 것을 볼 수 있습니다.

하지만 쓰레드를 한 번 생성할 때마다 OS가 해당 쓰레드를 위한 메모리 영역을 확보해주고, 쓰레드가 더이상 필요 없을 땐 다시 이 메모리 영역을 회수하는 작업이 일어나게 되어 쓰레드를 계속하여 생성하고 수거한다면 프로그램의 퍼포먼스에 영향을 끼치게 됩니다.

이를 해결하기 위해 작업이 들어올 때마다 미리 만들어져 있는 쓰레드들 중 하나에 작업을 할당할 수 있게 해주는 쓰레드 풀을 사용할 수 있습니다.

쓰레드 풀을 사용하면 퍼포먼스 저하 방지와 다수의 요청을 효율적으로 처리할 수 있는 장점이 있지만, 
너무 많은 쓰레드를 생성해두게 되면 메모리만 차지하고 아무것도 하지 않는 쓰레드가 존재할 가능성이 있어 자칫 메모리 낭비로 이어질 수 있는 단점이 있습니다.


### (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.
먼저 메시지 큐는 프로세스 또는 프로그램 간에 데이터를 교환할 때 사용하는 통신 방법 중 하나입니다.

일반적인 서버-클라이언트 구조에서는 사용자가 요청을 하면 서버는 그에 대한 처리를 한 후 사용자에게 응답을 합니다. 간단한 서버 구조에서는 굳이 Message Queue(이하 MQ)를 사용할 필요가 없습니다. 우선 MQ를 적용하려면 RabbitMQ, Kafka, ActiveMQ등 다양한 MQ 중에서 시스템 목적에 맞는 MQ를 선정해야 하고 또 서버에 MQ를 설치해야 하고, 사용 방법 및 라이브러리 사용법도 익혀야 합니다. 

그럼에도 메시지 큐를 사용해야 하는 이유는 첫번째로 기존 동기화 방식은 많은 메시지(데이터)가 전송될 경우 병목이 생길 수 있고, 뒤에 들어오는 요청에 대한 응답이 지연될 수 있지만 메시지 큐는 생산된 메시지의 저장, 전송에 대해 동기화 처리를 진행하지 않고(비동기 방식), 큐에 넣어 두기 때문에 나중에 처리할 수 있게 됩니다.
즉 서버 부하가 많은 작업을 효율적으로 처리할 수 있게 됩니다.

두번째로는 메시지 큐를 통해 분산 처리가 가능합니다. 여러 대의 서버가 하나의 큐를 바라보도록 구성하면 처리할 데이터가 많아져도 각 서버는 자신의 처리량에 맞게 태스크를 가져와 처리할 수 있게 됩니다.


### (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.) 
https://github.com/Jinnie-J/traveler

Java, Spring Framework, Oracle, AWS EC2를 활용하였습니다.

### (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.

백엔드 직무를 수행하려면 단순히 API 설계 능력 뿐만 아니라, 인프라와 Docker 그리고 클라우딩 컴퓨팅 등과 같은 서버에 대한 이해 또한 필요하다고 생각합니다. 

대용량 트래픽에서도 안정적이고 빠른 서비스를 제공할 수 있는 서버를 제공하는 방법에 대하여 배우고 싶습니다.

