## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

\*_문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요._

## 1-2) 사전 과제

- (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.

  - 동기와 비동기 프로그래밍은 작업이 순차적으로 진행되느냐 아니냐의 차이이고 직접적으로 스레드 수와 연관있는 개념이 아니다. 예를 들어 A, B, C라는 작업이 존재할 때 스레드가 하나냐 여러개냐와는 상관이 없고 A, B, C 순서로 작업이 연결되는가 아닌가이다.(연결된다는 의미는 A의 실행 결과가 B의 인자로 넘어간다는 의미는 아니고 A가 끝나고 B가 실행된다는 의미이다.) 이 순서를 구현할 때 스레드를 여러 개 사용하면 멀티스레드 비동기가 되는 것이고 스레드가 하나일 경우 싱글스레드 비동기가 된다.

  멀티스레드로 비동기를 구현하면 아래와 같다.

  - 1 start....end
  - 2 --------------start ..... end
  - 3 -----------------------------start ..... end

  싱글 스레드 동기를 구현하면 아래와 같다.

  1 start ... end start ... end start ... end

  보기 쉽게 표현하기 위해서 1, 2, 3번으로 나눈 것이지 실제로는 실행 순서는 정렬되지 않는다. 말하고 싶은 요지는 실행시간은 **멀티스레드를 비동기로 구현해도 효과는 싱글스레드 동기와 비슷한 효과를 내기 때문에** 일반적으로 비동기 멀티스레드로 프로그래밍을 하지 않는다.

- (2) 블로킹과 논블로킹의 차이점을 설명해주세요.

  - 위의 글에 이어서 싱글스레드 비동기를 나타내면 아래와 같다.

    ------start ... end

    -------start ... end

    --------start ... end

    이게 가능한 이유는 non-blocking I/O 이기 때문이다. 각각의 작업이 CPU를 사용하는 작업이 아닌 I/O가 필요한 작업은 현재 스레드가 실행하지 않고 다른 주체에게 대신 실행을 맡기기 때문에 작업이 끝나기를 기다리지 않고 다음 작업을 진행한다. 위 예에서는 모든 작업이 I/O 작업이기 때문에 실행이 끝나기 전에 다음 작업을 진행할 수 있는 것이다. 요약하면 non-blocking이란 현재의 작업이 끝나기까지 대기하지 않고 다음 작업을 시작하는 것을 의미한다.

- (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.

  - nodejs에서 callback과 promise, async/await을 주로 사용한다. 간단한 비동기 코드에서는 callback을 주로 사용하는데 코드가 복잡해지면 중첩된 callback으로 디버깅이 힘들고 가독성이 떨어지는 문제가 발생한다.

  ```jsx
  step1(function (value1) {
    step2(function (value2) {
      step3(function (value3) {
        step4(function (value4) {
          step5(function (value5) {
            step6(function (value6) {
              // Do something with value6
            });
          });
        });
      });
    });
  });
  ```

  이런 문제를 callback hell이라고 하는데 promise는 이런 문제를 해결하기 위한 기능이다. 프로미스는 다음과 같이 서술할 수 있다.

  ```jsx
  const callbackHellSolver = new Promise((resolve, rejects) => {
    // 실행해야하는 코드
    // 실행 결과가 정상이면 resolve 호출
    // 실행 결과가 에러면 rejects 호출
  });

  callbackHellSolver
    .then((result) => {
      // step 1
    })
    .then((result) => {
      // step 2
    });
  // .... 계속
  ```

  이렇게 promise를 사용하면 .then, .catch라는 체이닝을 이용할 수 있어서 중첩된 callbackHell을 피할 수 있어서 가독성이 좋아지고 디버깅이 훨씬 편리하다. 하지만 더 복잡해지면 가독성은 callback hell 수준이다.

  이것을 해결하기 위해서 async/await이라는 키워드가 추가되었는데 이 전보다 스타일이 깔끔해진다

  ```jsx
  async function sample() {
    // 비동기 함수
    const result = await callbackHellSolver();
    // 다음 비동기 코드

    const result2 = await callbackHellSolver2();
  }
  ```

- (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.

  1. 급작스런 트래픽이 몰리는 이벤트가 있을 경우

     트래픽이 증가할 때 보통 scale out을 사용하는데 갑작스런 트래픽이 몰릴 경우 예상대로 처리되지 않는다. scale out의 경우 cpu나 메모리 사용률이 일정 수치 이상일 때 instance를 생성하는데 이 시나리오를 웜업이라고 한다. 갑작스런 대규모 트래픽이 몰릴 경우 웜업이 끝나기도 전에 서버가 버티지 못하고 터져버려서 scale out이 제대로 동작을 할 수가 없다. 따라서 scale out을 버티기 위해서 사용자의 요청을 메세지큐에 저장을 하고 처리하는 서버가 하나씩 꺼내 사용하는 예가 있다.

  2. 시간이 오래 걸리는 비동기 작업이 있을 경우

     사진을 보정하는, 이미지 파일을 처리하는 작업이 있는 경우 서버에서 처리를 하고 사용자에게 응답을 하면 병목 지점이 발생하고 작업 서버에 대한 의존이 커진다. 이때 서버 앞에 메세지 큐를 둔다면 서버는 작업이 끝날때까지 응답을 대기하지 않고 빠르게 보낼 수 있다.

- (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.)

  - https://github.com/dimsssss/raid

- (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.

  실제 현업에서 쓰이는 구조의 서버 배포하기
