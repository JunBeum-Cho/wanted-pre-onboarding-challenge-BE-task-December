## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*
  


## 1-2) 사전 과제

### - (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.

데이터를 받는 형식에 있어서 동기와 비동기로 구분할 수 있다.

* 의미
- 동기적(synchronous) : 요청과 그 결과가 동시에 일어난다.
- 비동기적(asynchronously) : 요청과 결과가 동시에 일어나지 않는다.

* 장단점
동기 방식의 프로그래밍은 설계가 비교적 간단하고 직관적이나, 결과가 주어지기까지 마냥 대기해야 하는 단점이 있음.
비동기 프로그래밍은 결과가 나올 때까지 다른 작업을 할 수 있기 때문에 자원을 효율적으로 사용할 수 있으나, 비교적 복잡한 과정과 결과가 나올 때까지 시간이 걸림

### - (2) 블로킹과 논블로킹의 차이점을 설명해주세요.

먼저, 동기와 비동기, 블로킹과 논블로킹의 차이점에 먼저 알아두면 개념을 이해하는데 좀 더 도움이 된다.
동기와 비동기는 작업을 어떠한 흐름으로 처리할 것이냐, 블로킹과 논블로킹은 처리하고 있는 작업이 전체의 흐름을 막느냐 막지 않느냐에 차이가 있다.

블로킹과 논블로킹은 호출된 함수의 제어권을 두고 설명할 수 있다.

> 블로킹(Blocking)
호출된 함수가 자신의 작업이 종료될 때까지 제어권을 갖고 있는 것을 말한다. 즉, 호출된 함수의 작업이 종료될 때까지 호출하는 함수는 다른 작업을 진행할 수 없다.

> 논블로킹(Non-Blocking)
반면, 논블로킹은 호출된 함수가 자신의 작업이 종료되지 않았더라도 함수의 제어권을 자신을 호출하는 함수로 바로 넘겨주는 것을 말한다.

### - (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.

* Thread를 이용한 비동기 코드 작성
예를 들어 작업1과 작업2는 각각 처리시간이 오래 걸리고 짧게 걸린다고 했을 때, 작업 1이 끝나기를 기다렸다가 작업2를 시작하는 것은 매우 비효율 적이다. 이럴 때 스레드를 나누어 두 작업을 동시에 실행되게 하면 효율적이다.

* 비동기 처리
크게 Future 객체를 사용하는 방식과 Callback을 구현하는 방식이 있다. Future 객체는 다른 주체에게 작업을 맡긴 상태에서 본 주체 쪽에서 작업이 끝났는지 직접 확인하는 방법이고, Callback은 이름에서도 알 수 있듯 다른 주체에게 맡긴 작업이 끝나면 다른 주체 쪽에서 본 주체가 전해 준 콜백 함수를 실행하는 방법이다.

* Callback
콜백을 구현하는 방법은 여러 가지가 있다. CompletionHandler를 사용할 수도 있고, 함수형 인터페이스를 이용해서 구현할 수도 있다. CompletionHandler는 비동기 I/O 작업의 결과를 처리하기 위한 목적으로 만들어졌으며, 콜백 객체를 만드는 데 사용된다.

* Future
Future 객체를 사용한 비동기 처리 방식은 다른 주체에게 작업을 맡긴 상태에서 본 주체 쪽에서 작업이 끝났는지 물어보면서 직접 확인하는 방식으로 확인하는 방법으로는 두 가지가 있다. 하나는 isDone()이나 isCanceled() 메소드로 블로킹 없이 작업을 완료했는지의 여부만 확인하는 방법이고, 다른 하나는 get()으로 작업이 완료될 때까지 블로킹된 상태로 대기하는 방법이다.

### - (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.

MQ는 대용량 데이터를 처리하기 위한 배치 작업이나, 채팅 서비스, 비동기 데이터를 처리할 때 사용한다.
프로세스 단위로 처리하는 요청에 대한 사용자가 많아지거나 데이터가 많아지면 요청에 대한 응답을 기다리는 수가 증가 및 대기 시간이 지연되어서 서비스가 정상적으로 되지 못하는 상황이 오기 때문에 기존에 분산되어 있던 데이터 처리를 한 곳에 집중하면서 Queue를 두어서 필요한 프로그램에 작업을 분산시키는데 그 필요성이 있다.

1. Chat App에서는 유저가 메시지를 전송하고, 수신한다. 여기서 메시지 생성 외에도 유저는 메시지를 수신하거나 바로 다시 메시지를 생산하거나 다른 작업들을 진행할 수 있어야 한다. 유저가 생산한 메시지가 채팅에 참여한 사람에게 즉각적으로 채팅에 반영 되기를 원할 것이다. 유저들이 생산한 메시지를 즉각 모든 유저에 채팅방에 매번 반영하기 위해서는 각 메시지 처리에 대해 동기화를 진행해야 하고, 요청되는 양에 따라 서버에 부하가 걸려 많은 작업이 지연이 될 수밖에 없다. 그래서 MQ를 활용해 메시지 생성된 메세지를 Queue에 담은 후에, 메시지 수신자들에게 전달을 하게 되면 작업을 분리해 비동기로 처리할 수 있게 되면서 서버 성능을 개선할 수 있다.

2. 이미지 처리, 비디오 인코딩, 대용량 데이터 처리와 같은 작업에서도 MQ가 유용하다. 이 작업들은 메모리와 CPU를 많이 사용한다. 이러한 작업은 동시에 처리할 수 있는 양이 상당히 한정적이어서 필요하다고 무작정 요청을 처리할 수는 없다. 이 때에도 MQ를 사용하면 편리한데 처리해야할 작업을 MQ에 넣어두고 서버는 자신이 동시에 처리할 수 있는 양에 따라 하나의 작업이 끝나면 다음에 처리할 작업을 MQ에서 가져와 처리하면 된다.

### - (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.) 

 https://github.com/hyeding/Bucketlist-book.git
 
### - (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.
