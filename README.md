# 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*



# 1-2) 사전 과제


## (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.
<p align="center">
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fol0Ra%2Fbtq2Jy17oEy%2Fn4NdXDY3dGcNGI3eFxvr81%2Fimg.png" alt="동기 비동기" width="500">
<p>

### 동기 (Synchronous : 동시에 일어나는)
---
동시에 일어난다는 뜻이다. 요청과 그 결과가 동시에 일어난다는 약속이다.<br/>
바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 주어져야 한다.<br/>
요청과 결과가 한자리에서 동시에 일어난다.<br/>

### 비동기 (Asynchronous: 동시에 일어나지 않는)
---
동시에 일어나지 않는다를 의미한다. 요청과 결과가 동시에 일어나지 않을 것이라는 약속이다.<br/>
요청한 그 자리에서 결과가 주어지지 않는다.<br/>
노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다.<br/><br/><br/>


## (2) 블로킹과 논블로킹의 차이점을 설명해주세요.

블로킹과 논블로킹은 A 함수가 B 함수를 호출했을 때, 제어권을 어떻게 처리하느냐에 따라 달라진다.

### 1) 블로킹
블로킹은 A 함수가 B 함수를 호출하면, 제어권을 A가 호출한 B 함수에 넘겨준다.

<p align="center"><img src="https://user-images.githubusercontent.com/107676736/204207367-c6c63133-b05c-4e05-b159-f55f8b2ad5e3.png" width="350"><p>

1. A함수가 B함수를 호출하면 B에게 제어권을 넘긴다.
2. 제어권을 넘겨받은 B는 열심히 함수를 실행한다. A는 B에게 제어권을 넘겨주었기 때문에 함수 실행을 잠시 멈춘다.
3. B함수는 실행이 끝나면 자신을 호출한 A에게 제어권을 돌려준다.


### 2) 논블로킹
논블로킹은 A함수가 B함수를 호출해도 제어권은 그대로 자신이 가지고 있는다.

<p align="center"><img src="https://user-images.githubusercontent.com/107676736/204207398-95eb2184-fed1-4808-899a-d82dc676d0cf.png" width="350"><p>

1. A함수가 B함수를 호출하면, B 함수는 실행되지만, 제어권은 A 함수가 그대로 가지고 있는다.
2. A함수는 계속 제어권을 가지고 있기 때문에 B함수를 호출한 이후에도 자신의 코드를 계속 실행한다.<br/><br/><br/>


## (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.
  JAVA에서 비동기 처리를 위해 `Thread`, `Future`, `Callback` 등을 사용할 수 있다.<br/><br/><br/> 
  
  
## (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.
### 1. 이중화를 통한 지속성<br/> 
이중화는 메시지 큐의 가장 명백한 장점 중 하나이다. 보통 애플리케이션은 충돌, 시간 초과, 코드 오류 등의 기타 문제가 있다. 이는 특히 매달 수백만 또는 수십억 건의 트랜잭션을 처리하는 애플리케이션에서 적용된다.<br/>
큐는 메시지를 읽는 프로세스를 통해 트랜잭션이 완료되었으며 제거해도 안전하다는 것을 확인함으로써 이중화를 돕는다. 만약 어떤 것이 실패한다면, 메시지는 어딘가에 저장되어 있고 손실되지 않을 것이다. 나중에 재처리할 수 있다.
  
### 2. 효율을 위한 일괄 처리<br/> 
일괄 처리는 메시지 큐를 사용하는 좋은 이유다. 한 번에 1개씩, 100개씩 하는 대신 한 번에 100개의 레코드를 데이터베이스에 넣는 것이 훨씬 효율적이다. 우리는 ElasticSearch 와 SQL Server에 많은 데이터를 삽입한다. 일괄처리는 트랜잭션 규모를 조정함으로써 성능을 최적화할 수 있도록 도와준다.<br/><br/><br/> 
  
## (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.) 
  [모디라 백엔드 깃허브](https://github.com/modiraa/modira_BE)<br/> 
  CRUD와 단체 채팅 기능 담당
  <br/><br/> 
  
  
## (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.
