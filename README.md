## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*
  


## 1-2) 사전 과제

- (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.
    - 동기
        - 동기화: 똑같이 맞춘다.
        - 결과(답변)를 기다리는 것 (기다리는 상태: blocking)
        답변이 오면 다음 일 함 → 시간 비효율적
        - 결과가 중요한 경우에 사용
        - 코드가 작성 순서대로 실행됨
    - 비동기
        - 결과(답변)를 기다리지 않는 것 (기다리지 않는 상태: non-blocking)
        바로 다음 일 함 → 더 효율적으로 일 함 
        but, 결과를 확인할 수 없음 so 확인 업무 추가로 일 복잡해질 수 있음
        - 순서가 중요하지 않은 경우
        - 멀티태스킹으로 처리
        
- (2) 블로킹과 논블로킹의 차이점을 설명해주세요.
    - 블로킹 I/O → Synchronous
        - 예시) 모든 파일 입출력
            
                            2차 메모리(SSD, HDD) -  Driver -  NTFS 파일시스템  - 애플리케이션
            
            “A파일 열어줘”                        ←   3.    ←   2. 하위 요청   ←  1. 파일 입출력 요청
                              4. Disk에 다 썼어요 →   5.    →   6. return   ⇒ 동기모드 입출력
            
            **이 함수가 반환할 때까지 기다리는 것**
            
            5초면 5초동안 기다려야 됨
            
    - 논블로킹
        - 1.요청   2.    3. Return   (I/O 요청 Pending)    
          … (추후) 실제로 I/O 끝나면 Complete 통지 → Async로 수신
          
- (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.
    - JAVA
        - 비동기 케이스
            - JAVA의 코드 실행후 커맨드에서 입력 받기
            
                : 제어권이 시스템에서 사용자로 넘어감, 
                  리턴값이 필요하므로 사용자가 입력할 때까지 기다림
                
        - 새 Thread를 만들어서
        - 콜백을 구현
            - CompletionHandler를 사용
            - 함수형 인터페이스 사용
           
- (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.
    - 메세지 큐
        - 데이터를 교환할 때 메세지 지향 미들웨어를 구현한 시스템
            - 메세지 지향 미들웨어 : 비동기 메세지를 사용하는 프로그램 사이에서 데이터를 송수신하는 것
            - 메시지를 전송 및 수신하기 위해 중간에 메시지 큐를 두는 것
        - 예시
            - 회원가입 인증 이메일, 비밀번호 재설정 이메일 서비스를 위해
              이메일을 발급하는 일을 메세지 큐에 넣을 수 있음
                - 메일 전송 서비스는 그 큐에 있는 메일을 하나씩 전송
            - KAFKA
                - 스트림 프로세싱 소프트웨어
                - 발행 - 구독 모델을 기반으로 동작
                생산자, 소비자, 브로커로 구성
                - 메세지 저장소에 메시지가 전달되면
                필요에 따라 이벤트 스트림을 재생할 수 있음
                - 브로커는 Topic을 기준으로 메시지를 관리
                생산자는 특정 Topic의 메시지를 생성한 뒤, 브로커에 전달
                브로커가 Topic별로 분류해서 쌓아놓음
                해당 Topic을 구독하는 소비자들이 메시지를 가져가서 처리
                
- (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.)
    
    [https://github.com/catalinakim/OwnLog](https://github.com/catalinakim/OwnLog)
    
- (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.
    
    CI/CD (GithugAction등 방법을 활용한), AWS모니터링 (클라우드워치 사용방법)
