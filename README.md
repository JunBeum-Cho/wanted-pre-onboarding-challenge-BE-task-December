## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*
  


## 1-2) 사전 과제

### (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.

**동기**

동기는 데이터의 요청과 결과가 한 자리에서 동시에 일어나는것을 말합니다.

사용자가 데이터를 서버에게 요청한다면 그 서버가 데이터 요청에 따른 응답을 사용자에게 다시 리턴해주기 전까지 사용자는 다른 활동을 할 수 없으며 기다려야만합니다.

요청을 하면 시간이 얼마나 걸리던지 요청한 자리에서 결과가 주어져야 합니다.

ex)브라우저를 실행시키는 시간이 약 10분이 소모된다고 가정했을시, 브라우저가 실행되는10분이라는 시간 동안 사용자는 컴퓨터💻의 다른 프로그램들을동작시키지 못하며 브라우저가 켜지는 그 순간만을 계속 기다려야한다는 것입니다. 이 시간이 10분이든 100분이든 관계없이 **한 개의 데이터 요청에 대한 서버의 응답이 이루어질 때까지 계속 대기해야만합니다.**

**비동기**

비동기는 동시에 일어나지 않는다는 의미입니다.

요청한 결과는 동시에 일어나지 않을거라는 약속입니다.

서버에게 데이터를 요청한 후 요청에 따른 응답을 계속 기다리지 않아도되며 다른 외부 활동을 수행하여도되고 서버에게 다른 요청사항을 보내도 상관없습니다


**동기와 비동기의 장단점**

동기

장점 : 설계가 매우 간단하고 직관적이다.

단점 : 결과가 주어질 때까지 아무것도 못하고 대기해야 합니다.

비동기

장점 : 요청에 따른 결과가 반환되는 시간 동안 다른 작업을 수행할 수 있습니다.

단점 : 동기식보다 설계가 복잡합니다.

**정리**

- 동기와 비동기는 어떤 작업 혹은 그와 연관된 작업을 처리하고자 하는 목적의 차이 입니다.
- 동기는 추구하는 행위 와 목적이 동시에 이루어집니다
- 비동기는 추구하는 행위 와 목적이 다를 수도 있고, 동시에 이루어지지도 않습니다.

---
### (2) 블로킹과 논블로킹의 차이점을 설명해주세요.

블록과 논블록은 동기, 비동기와 연결되는 개념입니다

**블록**

블록이란 동기의 개념에서 만들어진 상태입니다

브라우저가(크롬) 실행되는 시간이 10분(요청)이라고 가정했을시에브라우저가(크롬) 이 오픈(결과) 되기전까지 다른 브라우저(사파리 등등)은 계속 대기해야 하는 상태를 블록 상태라고 부릅니다.

**논블록**

논블록이란 비동기 개념에서 만들어진 상태입니다

브라우저가(크롬) 실행되는 시간이 10분(요청)이라고 가정했을시에브라우저가(크롬) 이 오픈(결과) 되기전까지 다른 브라우저(사파리 등등)은 시간을 대기 하지 않고 제약없이 자유롭게 사용할수 있는 상황을 논블록 상태라고 부릅니다.

**정리**

- 블록이란 동기의 개념에서 만들어진 상태
- 논블록이란 비동기 개념에서 만들어진 상태

---

### (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.

**스레드를 사용한 비동기**
```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadExample {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();

        // 작업1 (스레드)
        executorService.submit(() -> {
            log("작업 1 시작");
            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log("작업 1 종료");
        });

        // 작업2
        log("작업 2 시작");
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log("작업 2 종료");

        executorService.shutdown();
    }

    // 출력을 어떤 스레드에서 하고 있는지 확인
    private static void log(String content) {
        System.out.println(Thread.currentThread().getName() + "> " + content);
    }
}
```
main> 작업 2 시작

pool-1-thread-1> 작업 1 시작

main> 작업 2 종료

pool-1-thread-1> 작업 1 종료


다음과 같이 작업 2가 먼저 시작되는 비동기 처리가 됐음을 확인할 수 있다

자바에서 비동기 처리를 하는 방식에는 크게 Future객체를 사용하는 방식과 Callback을 구현하는 방식이 있다

Future
다른 주체에게 작업을 맡긴 상태에서 본 주체 쪽에서 작업이 끝났는지 직접 확인하는 방법

Callback
다른 주체에게 맡긴 작업이 끝나면 다른 주체 쪽에서 본 주체가 전해 준 콜백 함수를 실행하는 방법

---

### (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.

**이메일 전송**

어떤 웹 사이트의 비밀번호를 잊어버려서 이메일을 통해 임시 비밀번호를 받거나, 새로운 회원가입을 위한 인증 코드를 받아본 경험이 있을 것이다. 우리는 이러한 상황들에서 이메일이 즉각적으로 수신되기를 기대하지는 않는다. 아무리 성격이 급한 사람이라도 몇 분 안에 오겠거니 생각할 것이다. 어느 정도의 응답 지연이 허용되며, 어플리케이션의 핵심 기능은 아닌 경우이므로 메시지 큐는 이런 경우 도움이 될 수 있다.

**블로그 포스팅**

모든 블로그 사용자가 웹에 최적화되어 있거나, 용량이 작은 이미지만 업로드하진 않을 것이다. 블로그 사용자가 게시글에 업로드한 이미지의 용량이 매우 큰 경우를 생각해보자. 블로그 서비스의 응답 시간을 저해하지 않으면서 사용자들에게 유연성을 제공하는 방법으로, 사용자가 업로드한 모든 이미지를 게시 과정에서 즉각 처리하는 것이 아닌, 사후처리하며 최적화하는 방법이 있다. 사용자 경험에 약간의 영향을 미칠 수는 있지만, 최적화는 응용 프로그램에서 가장 중요한 것은 아니며 작업을 즉시 수행할 필요도 없다. 메시지 큐는 이러한 상황에서도 사용될 수 있다.

---

### (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.) 

https://github.com/weejinyoung/board_practice

---

### (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.

실제 사용되는 서버 배포과정을 꼭 배우고 싶습니다
