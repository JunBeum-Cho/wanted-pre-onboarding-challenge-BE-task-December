## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*
  


## 1-2) 사전 과제

- (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.
- (2) 블로킹과 논블로킹의 차이점을 설명해주세요.
- (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.
- (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.
- (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.) 
- (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.


## 해답

### (1) 동기와 비동기 프로그래밍

#### 동기

동기 프로그래밍이란 요청에 따른 결과가 동시에 일어나는것을 말합니다. 

가령 사용자가 서버에 데이터를 요청할 경우 요청에 대한 응답을 리턴하기 전까지 다른 작업을 수행할 수 없으며, 해당 작업이 완료된 이후 다른 작업을 수행하게 됩니다.

#### 비동기

비동기 프로그래밍이란 요청에 따른 결과가 동시에 진행되지 않습니다. 

서버에 데이터를 요청할 경우 서버의 응답에 대해 기다리지 않으며 다른 작업을 수행할 수 있고, 응답이 올 경우에 다시 해당 작업을 수행할 수 있습니다.

### (2) 블로킹과 논블로킹의 차이점
#### 블로킹

블로킹은 동기의 개념에서 파생된 상태로서 A라는 함수가 모든 행위를 끝마칠때까지 기다렸다가 다른 함수가 실행하게 되면 이것을 블로킹 되었다고 합니다.

호출된 함수가 자신의 할 일을 모두 마칠때까지 제어권을 계속 가지고서 호출한 함수에게 바로 return 하지 않는 경우 블럭이라고 합니다

#### 논블로킹

함수 A를 호출하였을 경우, A가 끝나기 전에 B, C, D등 다른 함수들이 실행된다면 이것을 논블로킹이라고 합니다.

호출된 함수가 자신이 할 일을 마치지 않았다고 하더라도, 바로 제어권을 return하여 호출한 함수가 다른일을 진행할 수 있도록 합니다.

### (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.

node를 주로 사용하고 있으며, 해당 언어에서 비동기 프로그래밍을 사용하는 방법은 Promise 구문으로서 

1. then을 이용하여 비동기를 프로그래밍을 구현합니다.

```javascript
function getData() {
  return new Promise(function(resolve, reject) {
    $.get('url 주소/products/1', function(response) {
      if (response) {
        resolve(response);
      }
      reject(new Error("Request is failed"));
    });
  });
}
```

2. async, await을 이용하여 비동기 프로그래밍을 구현합니다.
```javascript
async function 함수명() {
  await 비동기_처리_메서드_명();
}

function fetchItems() {
  return new Promise(function(resolve, reject) {
    var items = [1,2,3];
    resolve(items)
  });
}

```


### (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.

메세지 큐를 이용하여 서비스간에 비동기적인 동작을 간편하게 구현할 수 있습니다.

모놀리틱 아키텍처에서 마이크로 서비스 아키텍처로 서비스를 분산하면서, 서비스와 서비스간에 느슨한 결합을 완성하기 위해서 메세지 큐를 이용하여 각 서비스를 연결합니다.

이를 통해 얻을수 있는 장점은

1. 데이터의 유실을 최소화 할 수 있다.

2. 하나의 기능을 담당하는 서비스가 장애가 발생하여도 다른 서비스로 장애가 전파되지 않는다 입니다.

예시로는 

1. 메세지 발행자와 이를 수행하는 워커를 서버리스로 구현하여 서버의 부하를 분산할 수 있습니다.
2. 주문-결제와 같이 외부 업체와의 연동이 필요한 경우 메세지 큐를 이용하여 `단기적으로 일관성을 잃더라도 결국에는 일관성을 유지하는 모델`을 구현할 수 있습니다.


### (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.) 

서버리스를 이용한 재고관리 시스템 구현
https://github.com/xgro/inventory_management

매장관리 API 프로젝트
https://github.com/xgro/continuous_deploy


### (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.
Elastic Beanstlak, ElastiCache, MSK, Lambda 운용 구조 등 AWS 서비스에 대해서 더욱 배우고 싶습니다. 