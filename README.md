## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*



## 1-2) 사전 과제

- (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.

  프로세스에서 실행 순서를 관리하는 방법에 대한 개념입니다.

  - **동기 프로그래밍**
    - A함수가 B함수를 호출할 때, B함수의 실행과 결과를 A함수가 확인하는 것입니다.
    - B함수가 미완료 상태라면, B함수가 끝날 때까지 계속 확인합니다. 
    - 이때, A함수는 A함수의 다른 일을 실행할 수 있지만, B함수의 결과가 필요한 일은 실행할 수 없습니다.
    - B함수가 완료되면, A함수의 나머지 일을 실행할 수 있습니다.

  - **비동기 프로그래밍**
    - A함수가 B함수를 호출할 때, B함수의 실행과 결과를 A함수가 확인하지 않는 것입니다.
    - A함수는 B함수의 실행, 결과와 상관없이 A함수를 실행합니다.
    - 멀티스레드로 구현할 수 있습니다.
    - 공유 자원을 사용하면 동시성 문제를 해결해야 합니다.

- (2) 블로킹과 논블로킹의 차이점을 설명해주세요.

  프로세스에서 실행의 제어권을 관리하는 방법에 대한 개념입니다.

  - **블로킹**
    - A함수가 B함수를 호출할 때, 호출된 B함수가 종료될 때까지 실행의 제어권을 B함수가 가지고 있는 것입니다.
    - A함수는 B함수가 종료되고 실행의 제어권을 돌려받은 후, 실행할 수 있습니다.
  - **논블로킹**
    - A함수가 B함수를 호출할 때, 호출된 B함수가 종료되지 않았더라도 실행의 제어권을 A함수에게 돌려줄 수 있는 것입니다.
    - A함수는 B함수가 종료되지 않았더라도 실행의 제어권을 가지고 있다면 실행할 수 있습니다.

- (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.

  ```java
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  
  public class Main {
      public static void main(String[] args) {
          ExecutorService executorService = Executors.newCachedThreadPool();
  
          executorService.submit(() -> {
              System.out.println("작업 1 시작 시간: " + System.currentTimeMillis());
              for (int i = 0; i < 100; i++) {
                  System.out.println("작업 1: " + i);
              }
              System.out.println("작업 1 종료 시간: " + System.currentTimeMillis());
          });
  
          System.out.println("작업 2 시작 시간: " + System.currentTimeMillis());
          for (int i = 0; i < 100; i++) {
              System.out.println("작업 2: " + i);
          }
          System.out.println("작업 2 종료 시간: " + System.currentTimeMillis());
          executorService.shutdown();
      }
  }
  ```

  - 쓰레드를 생성해서 비동기 프로그래밍을 할 수 있습니다.
  - 위 코드를 실행시키면 쓰레드로 생성한 작업 1과, Main 쓰레드의 작업 2가 서로의 실행 순서를 신경쓰지 않고 비동기적으로 실행됩니다. 

  

- (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.

  1. 다른 서비스와 비동기적으로 통신하여 작업을 분산할 수 있습니다.
     - 구매 서비스에서 물건을 구매한 후, 그에 대한 영수증을 이메일로 전송하는 경우를 생각하겠습니다. 
     - 구매 후에 이메일이 바로(동기적으로) 전송될 필요가 없기 때문에 메세지 큐를 이용할 수 있습니다.
     - 구매 서비스에서 이메일 전송 서비스의 메세지 큐에 메세지를 전송하고, 이메일 전송 서비스는 메세지 큐의 메세지들을 비동기적으로 처리하여 작업을 분산할 수 있습니다.

  2. 서버의 처리 능력에 맞추어 작업을 처리할 수 있습니다.

     - 메세지 큐에서 서버의 처리 능력만큼 메세지를 가져와서 처리하기 때문에 최적의 성능을 낼 수 있습니다.

     

- (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.) 

  https://github.com/OuOHoon/doby 웹 보드게임 플랫폼 백엔드 프로젝트입니다.

- (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.

  대규모 트래픽을 안정적으로 다룰 수 있는 시스템을 설계하는데 필요한 지식을 배우고 싶습니다!

