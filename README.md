## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*
  


## 1-2) 사전 과제

- (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.
- (2) 블로킹과 논블로킹의 차이점을 설명해주세요.
- (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.
- (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.
- (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.) 
- (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.

## (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.

- 데이터를 받는 방식에 대한 관점
- 처리해야 할 작업들을 어떠한 흐름으로 처리할 것인지에 대한 관점
    - 호출하는 함수의 작업 완료 여부를 신경 쓰냐
    - 함수 실행/리턴의 순차적인 흐름을 따르느냐

### 동기(Synchronous)

- Synchronous는 '동시에 일어나는'이라는 뜻이다.
    - 작업을 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작
    - 요청과 그 결과가 동시에 일어난다는 의미
        - 요청을 하면 시간이 얼마나 걸리든 요청한 자리에서 결과가 주어져야 함.
        - 추구하는 행위(목적)가 동시에 이루어짐.
- 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값을 계속 확인하면서 신경쓰는 것.
    - 함수 B로부터 리턴 받더라도 B의 작업이 미완료 상태이면 작업 완료 여부를 계속 신경쓰는 것.

### 비동기(Asynchronous)

- Asynchronous는 '동시에 일어나지 않는'이라는 뜻이다.
    - 요청과 결과가 동시에 일어나지 않을 거라는 의미
    - 하나의 요청에 대한 응답을 즉시 처리하지 않아도, 그 대기 시간 동안 또 다른 요청에 대한 처리가 가능하다.
    - 추구하는 행위(목적)가 다를 수 있고, 동시에 이루어지지 않음
- A 함수가 B 함수를 호출해도, A 함수는 B 함수의 작업 완료 여부를 신경 쓰지 않는다.
    - A 함수가 B 함수를 호출할 때, 콜백 함수를 전달해서 B 함수는 작업 완료 후에 콜백 함수를 실행시킨다.

## (2) 블로킹과 논블로킹의 차이점을 설명해주세요.

- 제어권 처리 방식에 관한 관점
- 처리되어야 하는 작업이 전체적인 작업 흐름을 막느냐, 안 막느냐의 차이

### 블로킹(Blocking)

- 자신의 작업을 실행하다가 다른 작업이 시작되면 다른 작업이 끝나기 전까지 기다렸다가 다시 자신의 작업을 재개
- A 함수가 B 함수를 호출하면, 제어권을 A 함수에서 B 함수로 넘긴다.
    - 제어권을 넘겨 받은 B 함수는 함수를 실행하지만 A는 제어권이 없기 때문에 함수 실행을 잠시 멈춘다.
    - B 함수는 실행이 끝나면 자신을 호출한 A에게 제어권을 돌려준다.

### 논블록킹 (Non-Blocking)

- 다른 작업과 관계없이 자신의 작업을 수행하는 것.
- A 함수가 B 함수를 호출해도 제어권을 그대로 자신이 가지고 있는다.
    - A 함수는 계속 제어권을 가지고 있기 때문에 B 함수를 호출한 이후에도 자신의 코드를 계속 실행한다.

## (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.

- Java에서는 Thread와 Future를 사용해서 비동기 프로그래밍을 할 수 있습니다. 하지만 작업을 할 때마다 쓰레드를 생성하게 되면 쓰레드가 무한히 증식되고 쓰레드 생성의 비용이 매우 크기 때문에 성능 저하 문제가 발생한다. 따라서 쓰레드 풀을 두어 일정 갯수의 쓰레드를 미리 생성해 둔 뒤 작업 큐에 작업이 있을 때 마다 쓰레드를 할당하여 작업을 처리하는 방식으로 구현한다. 작업은 Runnable 또는 Callable의 구현 클래스로 표현한다. Runnable을 구현한 작업은 리턴 값이 없고 Callable을 구현한 작업은 리턴 값이 있다. Callable 작업은 Future를 사용해 리턴값을 가져올 수 있는데 블로킹이 발생하는 문제가 있다. CompletableFuture를 사용하면 블로킹을 피하여 비동기 프로그래밍을 구현할 수 있다. 

## (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.

1. 비동기(Asynchronous)

   - 동기화 방식의 경우, 많은 메시지가 전송될 경우 병목 현상이 발생할 수 있어 뒤에 들어오는 요청에 대한 응답이 지연될 수 있다. 메시지 큐는 메시지 전송에 대한 동기화 처리를 하지 않고 단순히 큐에 넣어두기 때문에 나중에 처리가 가능하다.

2. 낮은 결합도(Decoupling)

   - 생산자 서비스와 소비자 서비스가 독립적으로 행동하게 됨으로써 서비스 간 결합도가 낮아진다.

3. 확장성(Scalable)

   - 생산자 서비스 혹은 소비자 서비스를 원하는 대로 확장할 수 있기 때문에 확장성이 좋다.

4. 탄력성(Resilience)

   - 소비자 서비스가 다운되어도 어플리케이션이 중단되지는 않음. 메시지는 여전히 메시지 큐에 남아 있음. 소비자 서비스가 다시 시작될 때마다 추가 설정이나 작업을 수행하지 않고도 메시지 처리를 시작할 수 있다.

5. 보장성(Guarantee)

   - 메시지 큐는 큐에 보관된 모든 메시지가 결국 소비자 서비스에게 전달된다는 일반적인 보장을 제공

### 용례

#### 이메일 전송

- 이벤트 알림, 회원가입 시 인증을 목적으로 유저들에게 이메일을 전송한다고 가정해보자. 이벤트 알림 메일을 생성하는 서비스(a 서비스), 인증 메일을 생성하는 서비스(b 서비스)는 메시지 큐에 이메일을 넣는 역할만 수행하고 유저에게 이메일을 전송하는 서비스(c 서비스)는 메시지 큐에서 이메일을 꺼내와 유저에게 이메일을 전송하는 역할만 수행한다. 메시지 큐를 사용함으로써 a, b 서비스와 c 서비스간의 결합도를 낮추고 a, b 서비스가 다운되어도 c 서비스에 영향을 주지 않는다(그 반대도 마찬가지다).

#### 채팅 프로그램

- 동기식 요청, 응답 방식으로 채팅 프로그램을 구현하면 사용자가 전송한 메시지에 대한 처리가 완료될 때까지 사용자는 다른 작업을 하지 못하고 기다려야만 하는 상황이 발생한다. 메시지 큐를 사용하게 되면 사용자는 메시지만 전송하고 다른 작업을 계속해서 수행할 수 있는 비동기성을 가지게 된다.

## (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요.

- <https://github.com/JunBeum-Cho/wanted-pre-onboarding-challenge-BE-task-December.git>
