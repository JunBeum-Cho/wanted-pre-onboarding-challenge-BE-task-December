## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*
  


## 1-2) 사전 과제

- (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.

 ▷ 동기 방식은 순서대로 처리 된다. 코드, 명령을 함과 동시에 데이터를 처리하기 때문에, 다음 줄로 넘어가기 위해선 윗 줄 명령이 끝나야 한다.
 요청과 결과가 한 자리에서 동시에 일어나기 때문에 동기 프로그래밍이라 한다.
 프로그래밍시 직관적으로 설계할 수 있으나, 현재 메인이 되는 작업과 밀접하지 않은 작업을 할 때 그것이 오래 걸릴 경우 메인 작업을 실행할 수 없다. 일반적인 객체지향 프로그래밍은 이 동기 처리를 기본으로 한다.

 ▷ 비동기 프로그래밍은 요청과 결과가 동시에 일어나지 않는다. 모든 명령이 비동기 처리일 경우 각각 따로 놀게 된다. 때문에 직관적인 설계가 힘들 수 있으나, 자원(시간)을 매우 아낄 수 있으며 일반적인 함수형 프로그래밍이 이 비동기 처리를 주로 이용한다.

- (2) 블로킹과 논블로킹의 차이점을 설명해주세요.

 ▷ 동기, 비동기의 중심이 작업 완료 여부라고 한다면, 블로킹과 논블로킹은 제어권을 어떻게 처리하냐는 문제다.
 ▷ 동기, 비동기가 어떤 흐름으로 작업을 처리하냐라는 것이면, 블록킹과 논블록킹은 어떻게 막는 지에 대한 관점이다.

 ▷ 블로킹은 A함수가 B함수를 호출할 때, 제어권을 A가 호출한 B 합수에세 넘겨 준다.
 ▷ 일반적인 java의 OOP 방식으로 프로그래밍 할 경우 동기 - 블로킹 방식으로 만들게 된다. 즉 함수를 실행하면 그 함수가 작업을 하고 완료됐을 때 다시 메인 명령으로 돌아오게 된다.
 ▷ 논블로킹은 A함수가 B합수를 호출하고 나서, A는 지 작업 알아서 하고 B는 A가 시킨 일을 한다. A가 제어권을 그대로 가지고 있기 때문에 A는 자기 코드를 그대로 실행하고 있을 것이다.
 ▷ 함수형 프로그래밍은 비동기 - 논블로킹 방식으로 많이 개발한다. 때문에 몇몇 동기적이어야 할 부분에서 Promise 같은 패턴을 쓰게 된다.

- (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.

 ▷ 프로젝트 진행시 개발 기획단계에선 있었고, 백엔드 개발은 했으나 프론트에서 소화를 못시킨 기능이 있었다.
 비밀번호를 잃어 버렸을 때, 다시 설정하는 기능이었는데, 가입 된 이메일로 UUID를 확인하고 앞단에 이 UUID로 비밀번호 찾기 페이지 요청이 들어오면 뒷단에 UUID를 보내서 검증한 뒤 앞단에서 비밀번호 재설정 페이지를 보내주는 방식이었다.
 이 경우 가입된 메일에 UUID 주소를 보내게 되는데, smtp 서버를 따로 구축하거나 구글을 쓰고 있을거기 때문에 시간이 걸린다.
 이에 DB에 해당 UUID, 이메일을 저장함과 동시에 smtp 서버에 메일을 보내라고 요청을 해야한다.
 이 때 Async 어노테이션을 통해 비동기 처리를 활성화하고 메일 보내는 메서드를 따로 만들어서 실행시켜주었다.
 이 후 UUID와 이메일을 저장한 DB를 삭제하기 위한 메서드도 비동기 처리를 해줬다. 명령과 동시에 10분 타이머를 작동, 10분뒤 명령이 실행되게끔 했다.
 단, 이 경우엔 Batch를 따로 만들어서 처리하는 편이 더 좋았을 것이다.

- (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.

 ▷ 생산자 서비스와 소비자 서비스가 독립적으로 행동하게 하여 결합도를 낮출 수 있다.
상기 (3)에서 쓴바와 같이 비밀번호 재설정을 위한 이메일 발송 서비스는 메인 어플리케이션과 결합도가 높을 필요성이 없다. 일종의 사이드 서비스라 볼 수 있기 때문이다.

 ▷ 대용량 서비스를 활용할 때 필요하다. 동영상이나 이미지를 인코딩하는 것은 CPU 부하가 많이 간다. 이에 서버가 처리할 수 있는 데이터만큼만 가져가는 것이 좋은데, 메세지 큐를 쓸 경우 이를 해결할 수 있다. 특히 Kafka의 경우 큐에 담긴 메세지를 pull 하는 방식이므로 소비자 서비스가 원하는 만큼 가져가는데 최적화 돼 있다. 부하 분산에도 매우 유리함.

- (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.)

▷ 팀프로젝트 - 주차장 자리 예약 주차고
https://github.com/Crazykwak/seb39_main_009

역할 : 팀장, 백엔드 전반

▷ 개인프로젝트 - 로또 번호 분석, 생성기 (미완성)
https://github.com/Crazykwak/lotto_random

역할 : 프로젝트 전반
