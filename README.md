## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*



## 1-2) 사전 과제

- (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.

  - 동기

    - 호출되는 함수의 **완료를 호출하는 쪽에서 확인하고 처리** 합니다.

    - 호출하는 함수는 호출되는 함수의 결과에 관심이 많습니다.

    - 예를들어 아래와 같은 함수가 있습니다.

      ```c
      char *set_string(char *str) {
        char * res = (char *)malloc(sizeof(char) * strlen(str));
        return res;
      }
      
      if (!set_string)
        //.....
      ```

    - 위와같이 set_string함수의 결과를 set_string을 호출한 쪽에서 확인하고 처리하는 방식이 동기 입니다.

  - 비동기

    - 호출되는 함수의 **완료를 호출되는 함수에게 알아서 하라고** 합니다.

    - 호출하는 함수는 호출되는 함수의 결과에 관심 없습니다.

    - 예를들어 아래와 같은 함수가 있습니다.

      ```typescript
      async findOneById(id: number) {
        return await this.authRepository.findById(id);
      }
      ```

      데이터를 조회하는 함수입니다. 호출된 함수는 데이터를 찾는다면 적절한 값을 return해줄것이며
      그건 지금 당장은 아닙니다. 호출된 함수가 완료하면 그때 성공과 실패를 알려줄 것입니다.

- (2) 블로킹과 논블로킹의 차이점을 설명해주세요.

  - 블로킹
    - 동기의 코드 예시를 보면 set_string함수를 호출한 시점에 호출한 함수는 제어권을 잃게 됩니다
    - set_string 함수가 끝날때 까지 제어권은 set_string함수에게 있습니다.
    - 이처럼 블로킹은 호출한 함수가 제어권을 잃어 **호출된 함수가 끝날때까지 아무것도 하지 못하는 상태입니다.**
  - 논블로킹
    - 비동기 코드 예시를 보면 this.authRepository.findById 함수를 호출한 시점에 제어권을 잃지 않습니다(사실 코드에 그게 보이지는 않지만...)
    - 호출한 함수가 제어권을 계속 가지고 있기 때문에 호출된 함수가 끝나면 결과만 받아서 보면 됩니다.
    - **호출한 함수는 호출된 함수를 기다리지 않고 다른 할일이 가능합니다.**

- (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.

  - Typescript에서 async/await를 사용합니다.

    ```typescript
    async findOneById(id: number) {
      return await this.authRepository.findById(id);
    }
    ```

    방금 non-blocking 예제에 사용했던 코드입니다. async/await 를 사용하는 이유는
    사람이 이해하기 쉬운 코드를 작성하기 위해서입니다.
    겉으로 보기에는 동기 예제와 다른것이 없습니다. 하지만 await가 끝까지 결과를 기다리고 있는게 아니라
    내부적으로 .then, .catch를 동작시켜 성공, 실패를 반환하게 됩니다. 체이닝을 하지 않아도
    깔끔하게 비동기 상태를 표현 가능하기 때문에 async, await를 사용합니다.

- (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.

  - 메세지 큐를 쓰면 요청/응답의 비동기적 구현이 가능하다! 그로인한 이점이 많지만 딱 두 가지만 선택한다면 아래와 같습니다.

    - 서비스의 낮은 결합도

      -- 생산자 서비스와 소비자 서비스가 종속적으로 동작하는게 아니라 소비자는 큐에 있는 결과를 꺼내서 쓰기만 하기 때문에
      결합된 모델보다 효율적으로 동작 가능합니다.

    - 확장성

      -- 위와 같은 이치입니다. 결합도가 낮아서 기능의 확장이 필요하다면 결합된 모델보다 비교적 쉽게 확장이 가능합니다.

- (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.) 

  - [c++ I/O Multiplexing Web Server ](https://github.com/weg901127/webserv)
  - [Online PingPong Game Server(진행중)](https://github.com/weg901127/back_end)

- (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.

  - aws를 이용해서 로그를 수집, 가공하는 파이프라인을 만들어보고 싶어요!
