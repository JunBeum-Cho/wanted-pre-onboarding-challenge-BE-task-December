## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*
  


## 1-2) 사전 과제

- (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.
- (2) 블로킹과 논블로킹의 차이점을 설명해주세요.
- (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.
- (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.
- (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.) 
- (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.


# 과제 제출
## (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.

둘의 차이점의 키-포인트는 _**순서**_ 입니다.
```text
함수 A() {
  B();
  C();
}

함수 B() { /* 실행... */ }
함수 C() { /* 실행... */ }
```

> A 함수 실행하면?

### 동기 (Synchronous)
A는 B가 작업이 완료되었는지 확인하고 요청이 완료되면 C를 실행하게 됩니다.
<br>
B → C 순서대로 실행이 되고, 실행 순서를 보장하게 됩니다.

고길동이 둘리와 도우너에게 일을 맡긴다고 생각해봅시다.
- **[🗡️고길동]** : 둘리, 자료좀 정리해줄래?
- **[🪄둘리]** : Yes, sir!
- (둘리 자료 정리 중...)
- **[🗡️고길동]** : (둘리 작업을 기다리며...) 둘리, 아직 멀었니??
- **[🪄둘리]** : 지금 끝났습니다!
- **[🗡️고길동]** : Okay! 다음 도우너, 이거 검토 부탁해!
- **[🎻도우너]** : 넵!
- (반복...)

고길동은 둘리의 작업을 신경쓰며 기다리다가 작업이 완료 되면 도우너에게 일을 맡기게 됩니다.
<br>
둘리의 일이 끝날때까지 기다리고 신경쓴다는 점에서 어떻게 보면 비효율적일 수 있습니다.
<br>
하지만 자료가 준비되지 않았는데, 검토를 할 수는 없겠죠? 🤔
<br>
이와 같이 순차적으로 진행을 해야될 때 사용하게 됩니다.

### 비동기 (Asynchronous)
A가 B를 호출 할때 콜백 함수를 함께 전달해서, B가 완료되면 콜백 함수를 실행합니다.
<br>
이는 즉 각 B, C가 각각 수행과 종료를 스스로 처리하는 것을 말합니다.
<br>
A는 B, C의 작업 완료 여부는 전혀 신경을 쓰지 않기 때문에 B, C 중에 무엇이 먼저 끝나는지 알 수 없습니다.
<br>
즉 실행 순서를 보장하지 않습니다.

고길동이 둘리와 도우너에게 일을 맡긴다고 생각해봅시다.
- **[🗡️고길동]** : 둘리, 발표 자료 A안 준비 해줘.
- **[🪄둘리]** : Yes, sir!
- (둘리 자료 정리중...)
- **[🗡️고길동]** : (기다리지 않고 바로) 도우너, B안 부탁할게!
- **[🎻도우너]** : 넵!
- (도우너 자료 정리중...)
- **[🗡️고길동]** : (회의장으로 발걸음을 옮기며...) 나는 회의 참석하러 갈게! 파이팅!

`동기(Synchronous)`와는 다르게 둘리의 작업을 기다리지 않고 도우너에게 일을 맡기고 본인도 본인 업무를 하러 갑니다.
<br>
이렇게 각자가 동시에 업무를 처리하기 때문에 매우 효율적으로 업무 처리를 할 수 있습니다.
<br>
이와 같이 순차적으로 진행할 필요가 없다면 효율적으로 비동기적 방식을 많이 사용합니다.

⚠️ 주의할 점은 순서를 보장하지 않기 때문에, 둘리와 도우너 중에 누가 업무를 먼저 끝낼지는 알 수가 없습니다.
<br>
그래서 만약에 둘리가 먼저 일을 끝내야 한다면 비동기적 방식보다는 동기적 방식을 사용하는것이 좋습니다.

## (2) 블로킹과 논블로킹의 차이점을 설명해주세요.
둘의 차이점의 키-포인트는 _**제어권**_ 입니다.
```text
함수 A() {
  B();
  // 다음 작업!
}

함수 B() {
  // 열심히 실행!
}
```

> A 함수 내에서 B 함수 실행 시?

### 블로킹 (Blocking)
A는 B에게 제어권을 넘겨주고, 함수 실행을 잠시 멈춥니다(Block!).
<br>
B는 함수를 실행하고 A에게 제어권을 넘겨줍니다.
<br>
A는 제어권을 넘겨받고 나서 다음 작업을 이어갑니다.

`Javascript`로 예시를 들어보겠습니다.
<br>
`alert()` 함수로 설명해보겠습니다.
```javascript
alert('Hi!');
console.log('Bye!');
```
위의 작업의 결과는 보이는 바와 같이 아래와 같습니다.
```shell
# 메시지 알림으로 Hi! 팝업
Bye!
```
메시지 팝업으로 `Hi!`를 보여준 후에 `Bye!`가 콘솔로 출력됩니다.
<br>
이는 `alert` 함수로 제어권이 넘어가서 실행을 완료되기 전까지 Block 됩니다.
<br>
메시지 창을 닫고 나서야 제어권이 다시 돌아와 다음 작업을 실행하게 되는 것이죠.

### 논블로킹 (Non-blocking)
A에서 B를 호출하지만 B가 바로 제어권을 반납하여 A가 제어권을 가지게 됩니다.
<br>
A는 B를 호출하고도 계속해서 다음 작업을 실행합니다.

똑같이 `Javascript`로 예시를 들어보겠습니다.
<br>
비동기 함수로 사용되는 `setTimeout()`로 설명해볼게요.
```javascript
setTimeout(() => 
  console.log('Hi!'), 0); // 2번째 매개변수: 대기 시간을 0으로 설정!
console.log('Bye!');
```
위의 작업을 실행하게 되면 어떻게 될까요?
<br>
정답은 아래와 같습니다.
```shell
Bye!
Hi!
```
제어권을 바로 반납 받아 (`Hi!`를 기다리는 것이 아닌) `Bye!`를 실행하게 되기 때문입니다.
<br>
이렇게 제어권을 바로 반납 받아 다른 일을 할 수 있도록 하는것을 논블로킹이라고 합니다.