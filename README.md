## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*
  


## 1-2) 사전 과제

- (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.
    ```text
    동기/비동기는 일을 수행 중인 동시성에 주목한다 입니다.

함수 A와 B라고 똑같이 생각했을 때, B의 수행 결과나 종료 상태를 A가 신경 쓰고 있는 유무의 차이라고 생각합니다.

Synchronous : 함수 A는 함수 B가 일을 하는 중에 기다리면서, 현재 상태가 어떤지 계속 체크합니다.
Asynchronous : 함수 B의 수행 상태를 B 혼자 직접 신경 쓰면서 처리합니다.(Callback)
즉, 호출된 함수(B)를 호출한 함수(A)가 신경 쓰는지, 호출된 함수(B) 스스로 신경 쓰는지를 동기/비동기라고 생각하면 됩니다.

비동기는 호출 시 Callback을 전달하여 작업의 완료 여부를 호출한 함수에게 답하게 됩니다. (Callback이 오기 전까지 호출한 함수는 신경 쓰지 않고 다른 일을 할 수 있음)
 
    ```

- (2) 블로킹과 논블로킹의 차이점을 설명해주세요.
  ```text
블록/논 블록은 간단히 말해서 호출된 함수가 호출한 함수에게 제어권을 건네주는 유무의 차이라고 볼 수 있습니다.

함수 A, B가 있고, A 안에서 B를 호출했다고 가정하면, 이때 호출한 함수는 A고, 호출된 함수는 B가 됩니다. 현재 B가 호출되면서 B는 자신의 일을 진행해야 합니다. (제어권이 B에게 주어진 상황)

Blocking : 함수 B는 내 할 일을 다 마칠 때까지 제어권을 가지고 있습니다. A는 B가 다 마칠 때까지 기다려야 합니다.
Non-blocking : 함수 B는 할 일을 마치지 않았어도 A에게 제어권을 바로 넘겨줍니다. A는 B를 기다리면서도 다른 일을 진행할 수 있습니다.
즉, 호출된 함수에서 일을 시작할 때 바로 제어권을 리턴해주느냐, 할 일을 마치고 리턴해주느냐에 따라 블록과 논 블록으로 나누어진다고 볼 수 있습니다
  ```

- (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.
  ```text
  저는 Java를 주로 사용합니다.
  Java에서 비동기 처리를 위해서는 Thread를 사용할 수 있습니다.
  Thread의 작업 처리가 많아지면 성능이 저하되는 단점이 있습니다. 이를 보완하기 위해서 스레드 풀을 사용할 수 있습니다.
  Thread의 개수를 미리 정하고, 작업 큐에 들어오는 요청을 미리 생성한 Thread에게 할당하는 방법입니다.
  하지만 스레드풀도 여러 개의 Thread를 만들었지만, 사용되는 Thread가 적다면 나머지는 메모리만 차지한다는 단점이 있습니다.
  ```

- (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.
 ```text
 데이터 처리의 복잡성을 줄이고, 의존성을 최소화를 위해 사용합니다.
    - 각 서비스를 분리할 수 있어 느슨한 의존성을 만들 수 있어 MSA 환경에서 많이 사용됩니다.
    - Kafka의 경우 End to End 방식의 아키텍처를 Producer + Consumer 아키텍처로 변경해 구조가 단순하게 변경됩니다.
  - 일괄처리를 위해 사용하는 경우도 있습니다.
 ```
  
- (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.) 
  ```text
  먼저 메시지 큐는 클라이언트와 서버 사이에 위치합니다.
  서버의 부하가 많은 작업의 경우 메시지 큐에 요청을 미리 담아두고 서버에게 하나씩 처리하게 할 수도 있습니다.
  서버가 여러 대인 경우에도 메시지 큐에 요청을 미리 담는다면 A서버, B서버...등등 서버들에게 동등한 작업량을 제공할 수 있습니다.
  이렇게 되면 각 서버에 드는 부하는 적어지고 서버 다운이 일어날 확률이 줄어듭니다.
  
  메시지 큐를 통해 분산 처리를 하면서 서비스의 속도가 향상될 수 있고, 서비스를 여러 부분으로 나누고 독립적인 확장하기 용이합니다.
  또한 메시지 큐를 통해 동시성 문제를 해결할 수 있습니다. 조회수 같은 문제에 대해 메시지 큐에 담긴 요청이 순차적으로 분산되기 때문에 가능합니다.
  ```

- (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.)
  ```text
  https://github.com/kimtaesoo99/ShoppingMall_RESTAPI
  쇼핑몰 기능을 만들어본 프로젝트입니다.
  ```

- (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.
  ```text
  베포를 해본적이있지만, 따라하기 식이였고, 완전히 이해하지 못하였었습니다. 이번 기회에 정확하고 제대로 배워보고싶습니다.
  백엔드 개발자로서 aws 지식을 쌓으면, 더욱 좋은 개발자가 될것이라고 기대됩니다!
  ```
