## 1-1) 사전과제 진행 가이드

- 아래 총 5 문제에 대한 해설을 작성한 뒤 Pull Request를 날려주세요.
- 문제 해설에 대한 정해진 양식은 없으며, 최대한 자세히 해설해주시면 좋습니다.
- 문제 유형은 해당 코스에서 다룰 주제들을 포함하고 있으니 완벽히 이해하시면 코스를 수강하는데 큰 도움이 될 것입니다.

**문의 사항은 사전 과제 Repository의 Issue로 등록해 주세요.*
  


## 1-2) 사전 과제

- (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.

  동기와 비동기의 차이는 호출되는 함수의 작업 완료 여부를 신경쓰는지의 여부의 차이입니다.

    1) 동기
    
      함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값을 계속 확인하면서 신경쓰는 것이 동기입니다.

    2) 비동기
    
      함수 A가 함수 B를 호출할 때 콜백 함수를 함께 전달해서, 함수 B의 작업이 완료되면 함께 보낸 콜백 함수를 실행합니다.
     
      함수 A는 함수 B를 호출한 후로 함수 B의 작업 완료 여부에는 신경쓰지 않습니다.
  
- (2) 블로킹과 논블로킹의 차이점을 설명해주세요.

    블로킹과 논블로킹은 A 함수가 B 함수를 호출했을 때, 제어권을 어떻게 처리하느냐에 따라 달라집다.
  
    1) 블로킹
    
      블로킹은 A 함수가 B 함수를 호출하면, 제어권을 A가 호출한 B 함수에 넘겨줍니다.
      
    2) 논블로킹
    
      논블로킹은 A함수가 B함수를 호출해도 제어권은 그대로 자신이 가지고 있습니다.
  
- (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.

    자바스크립트에서 비동기 프로그래밍은 3가지 방식이 있습니다.
  
    1) Callback function
    
      자바스크립트에서 비동기 함수인 setTimeout의 첫번째 인자는 함수입니다. 이 함수는 콜백 함수로서 사용됩니다.
      
      console.log('Hi');
      setTimeout(function cb1() {
        console.log('cb1');
      }, 5000);
      console.log('Bye');
    
    2) Promise
    
      Promise는 비동기 함수로서 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행합니다.
      
      const promise = new Promise((resolve, reject) => {
        if(/* 비동기 처리 성공 */) {
          resolve("성공");
        } else { /* 비동기 처리 실패 */
          reject("실패");
        }
      });
      
      후속 처리 메서드(then/catch/finally)로 성공이나 실패시의 결과값을 처리할 수 있다.
      
      const promise = new Promise((resolve, reject) => {
        if(/* 비동기 처리 성공 */) {
          resolve("성공");
        } else { /* 비동기 처리 실패 */
          reject("실패");
        }
      }).then((data) => {
        console.log(data);
      }).catch((error) => {
        console.log(error);
      })
      
    
    3) Async/Await
    
      Async/Await을 사용하면 후속 처리 메서드(then/catch/finally)에 콜백 함수를 전달할 필요 없이 마치 동기 처리처럼 Promise를 사용할 수 있습니다.
      
      const fetch = require("node-fetch");
      async function getLotto() {
        const url = "https://www.dhlottery.co.kr/common.do?method=getLottoNumber&drwNo=1043";
        
        const response = await fetch(url);
        const lotto = await response.json();
        console.log(lotto);
        // {"totSellamnt": 107045942000, "returnValue": "success", "drwNoDate": "2022-11-26", ... , "drwtNo1": 3}
      }
      
      getLotto();
      
- (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.

    메시지 큐는 프로세스 또는 프로그램 간에 데이터를 교환할 때 사용하는 통신 방법 중에 하나입니다.
    
    메시지 지향 미들웨어(MOM : Message Oriented Middleware)를 구현한 시스템으로 프로그램(프로세스) 간의 데이터를 교환할 때 사용하는 기술입니다.
    
    메세지 큐를 쓰는 이유는 비동기 메시징과 트랜잭션 순서 및 동시성 문제 때문에 사용합니다.
    
    1) 비동기 메시징
    
      대기열은 애플리케이션에 무언가 수행이 필요하지만 지금 수행 할 필요가 없거나 결과에 신경을 쓰지 않는 시나리오에서 유용 할 수 있습니다. 
      
      웹 서비스를 호출하고 완료 될 때까지 기다리는 대신 큐에 메시지를 쓰고 나중에 동일한 비즈니스 로직이 발생하도록 할 수 있습니다.
    
    2) 트랜잭션 순서 및 동시성 문제
    
      만약 1000명의 사람들이 한 번에 당신의 웹사이트에 주문을 한다면, 그것은 동시성과 첫 번째 주문이 먼저 끝나도록 하는 것에 약간의 문제를 야기할 수 있습니다.
      
      줄을 서면 주문을 보장하고 동시에 처리되는 개수의 수를 제어할 수 있습니다.
  
- (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.)

  https://github.com/ad105geppetto/sns-board-api
  
- (6 - Optional) 해당 수업을 통해 꼭 배우고 싶은 주제 또는 지식이 있다면 자유롭게 서술해주세요.

  수천만명의 트래픽을 관리할 수 있는 클라우드 아키텍쳐에 대해 궁금합니다.
  
  또한, 소/중/대규모별로 트래픽을 관리한다면 무엇을 기준으로 트래픽을 관리하는지도 궁금합니다.
  
  트래픽을 확인하는 툴도 소개해주신다면 좋을 것같습니다.
  
