#### (1) 동기와 비동기 프로그래밍에 대한 차이점을 설명해주세요.
동기 방식은 요청이 발생하면 시간이 얼마나 걸리던 그 자리에서 결과가 주어지는 방식이다.
설계과 직관적이지만 결과값을 구하는 시간이 오래 걸리면 그 시간 동안 대기해야 하는 단점이 있다.

비동기 방식은 요청이 들어와도 결과를 즉시 처리하지 않아도 다음 동작이 진행되는 방식이다.
동기 방식보단 복잡하지만 결과가 주어지는 데 시간이 걸리더라도 다른 작업을 할 수 있어 효율적이다.

예를 들어 패스트푸드점에서 햄버거를 주문한다고 가정하면 햄버거를 주문하고 받기 전까지 다른 사람이 주문을 못하는 방식을 동기방식, 카운터가 햄버거 주문을 계속 받고 햄버거가 만들어지는 대로 받는 방식을 비동기 방식이다.


#### (2) 블로킹과 논블로킹의 차이점을 설명해주세요.
블로킹과 논블로킹은 처리되어야하는 작업이 전체적인 작업 흐름을 막느냐 안막느냐에 대한 관점이다.
블로킹은 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것이다. A함수가 B함수를 호출하면 제어권을 B함수에게 넘긴다. B함수가 작업을 끝내면 호출한 A함수에게 제어권을 돌려준다.
논블로킹은 다른 주체의 작업에 관련 없이 자신의 작업을 하는 것이다. A함수가 B함수를 호출하여도 제어권은 그대로 A함수가 가지고 있다. B함수를 호출하면 B함수는 실행되지만, A함수는 제어권을 가지고 있기 때문에 자신의 코드를 계속 실행한다.


#### (3) 본인이 주로 사용하는 언어에서 비동기 프로그래밍을 사용하는 방법을 설명해주세요.
```
import time
import asyncio  # asyncio 모듈 임포트

async def download_page(url) :  # async def로 비동기 함수 정의
    await asyncio.sleep(1)
    print("complete download:", url)
    
async def main() :
    await asyncio.gather(       # asyncio.gather() 사용해 여러 비동기 함수를 동시 등록
        download_page("url_1"),
        download_page("url_2"),
        download_page("url_3"),
        download_page("url_4"),
        download_page("url_5")
    )
    
print(f"stated at {time.strftime('%X')}")
await main()    # 비동기 함수 실행
print(f"finish at {time.strftime('%X')}")

# await 를 사용하면 비동기 작업이 완료되었다는 통보가 올 때까지 대기하지만,
# event loop 를 확인하여 event loop 내 task 가 존재한다면 그 일을 처리한다.
# asyncio.gather() 를 이용하여 await 키워드가 붙은 download_page() 을 event loop 에 등록한다.
# 이후 asyncio.run() 함수를 통해 비동기 함수를 호출하면 된다.
```

#### (4) 메세지 큐를 쓰는 이유에 대하여 2가지 예시를 서술해주세요.
메세지 큐는 프로세스 간에 데이터를 교환할 때 사용되는 통신 방법 중에 하나이다.
메세지 큐는 메세지를 임시로 저장하는 간단한 버퍼로 생각할 수 있다. 메세지(데이터)를 전송 및 수신하기 위해 중간에 메세지 큐를 두는 것이다.
메세지 큐는 다음과 같은 장점이 있다.
1. 비동기: Queue에 넣어 나중에 처리 가능하다.
2. 비동조: 애플리케이션과 분리할 수 있다.
3. 확장성: 여러 개의 서비스들이 큐에 메세지를 보낼 수 있다.
4. 탄력성: 일부가 실패해서 전체에 영향을 주지 않는다.
5. 과잉: 실패할 경우 재실행이 가능하다.
6. 보장성: 보관된 메시지를 결국 소비자 서비스에게 전달됨을 보장한다.

이미지 처리, 빅데이터 등 대용량 데이터 처리와 같이 서버 부하가 많은 작업에서 메세지 큐를 사용하면 
메세지를 즉시 처리하지 않고 큐에 저장하여 비동기로 처리할 수 있으며, 확장하여 분산 처리도 가능하다.
기존 애플리케이션과 DB가 강하게 결합되어 있는 경우 DB 장애 발생 시 애플리케이션도 영향을 받게 된다. 두 서비스 사이에 메세지큐를 두어 DB 단에 처리해야 할 양이 많아지면 메시지큐에서 처리량을 제어할 수 있다.


#### (5) 본인이 작성한 서버 코드가 있는 github repo 주소를 제출해주세요. (CRUD 기능을 모두 포함하여야 하며, 서버에 대한 설명을 README에 작성해주시면 더욱 좋습니다.)
https://github.com/heosh/pension
https://github.com/heosh/spring-study
